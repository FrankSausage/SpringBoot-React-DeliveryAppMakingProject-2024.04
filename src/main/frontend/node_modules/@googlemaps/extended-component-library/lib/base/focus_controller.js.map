{"version":3,"file":"focus_controller.js","sourceRoot":"","sources":["../../src/base/focus_controller.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAIH;;;;;;;;;;;;GAYG;AACH,MAAM,OAAO,eAAe;IAM1B,IAAI,oBAAoB;QACtB,OAAO,IAAI,CAAC,4BAA4B,IAAI,KAAK,CAAC;IACpD,CAAC;IAiBD,YACqB,IAAuC,EACvC,cAC0B;QAF1B,SAAI,GAAJ,IAAI,CAAmC;QACvC,mBAAc,GAAd,cAAc,CACY;QAlB9B,2BAAsB,GAAG,GAAG,EAAE;YAC7C,IAAI,IAAI,CAAC,4BAA4B,KAAK,KAAK,EAAE;gBAC/C,IAAI,CAAC,4BAA4B,GAAG,KAAK,CAAC;gBAC1C,IAAI,IAAI,CAAC,cAAc;oBAAE,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;aACrD;QACH,CAAC,CAAC;QAEe,yBAAoB,GAAG,CAAC,EAAC,GAAG,EAAgB,EAAE,EAAE;YAC/D,IAAI,GAAG,KAAK,KAAK,IAAI,GAAG,KAAK,OAAO;gBAAE,OAAO;YAC7C,IAAI,IAAI,CAAC,4BAA4B,KAAK,IAAI,EAAE;gBAC9C,IAAI,CAAC,4BAA4B,GAAG,IAAI,CAAC;gBACzC,IAAI,IAAI,CAAC,cAAc;oBAAE,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;aACpD;QACH,CAAC,CAAC;QAMA,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IAChC,CAAC;IAED,aAAa;QACX,QAAQ,CAAC,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAAC,oBAAoB,CAAC,CAAC;QAChE,QAAQ,CAAC,gBAAgB,CAAC,WAAW,EAAE,IAAI,CAAC,sBAAsB,CAAC,CAAC;IACtE,CAAC;IAED,gBAAgB;QACd,QAAQ,CAAC,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAAC,oBAAoB,CAAC,CAAC;QACnE,QAAQ,CAAC,mBAAmB,CAAC,WAAW,EAAE,IAAI,CAAC,sBAAsB,CAAC,CAAC;IACzE,CAAC;CACF","sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {LitElement, ReactiveController, ReactiveControllerHost} from 'lit';\n\n/**\n * Controller to help customize focus behavior depending on if the user is\n * keyboard navigating with Tab and Enter.\n *\n * The controller's boolean property `isKeyboardNavigating` is flipped to true\n * when the user presses Tab or Enter, and flipped to false when they click the\n * mouse.\n *\n * The controller optionally accepts a callback that it calls whenever\n * `isKeyboardNavigating` changes. This can be used, for example, to toggle a\n * class in the host's shadow DOM to remove the default focus ring with CSS,\n * when it appears due to keypresses other than Tab/Enter.\n */\nexport class FocusController implements ReactiveController {\n  // Initialize the internal state to undefined so that the change callback is\n  // called on the first mousedown, even though externally the state is going\n  // from false to false.\n  private isKeyboardNavigatingInternal?: boolean;\n\n  get isKeyboardNavigating(): boolean {\n    return this.isKeyboardNavigatingInternal ?? false;\n  }\n\n  private readonly mousedownEventListener = () => {\n    if (this.isKeyboardNavigatingInternal !== false) {\n      this.isKeyboardNavigatingInternal = false;\n      if (this.changeCallback) this.changeCallback(false);\n    }\n  };\n\n  private readonly keydownEventListener = ({key}: KeyboardEvent) => {\n    if (key !== 'Tab' && key !== 'Enter') return;\n    if (this.isKeyboardNavigatingInternal !== true) {\n      this.isKeyboardNavigatingInternal = true;\n      if (this.changeCallback) this.changeCallback(true);\n    }\n  };\n\n  constructor(\n      private readonly host: ReactiveControllerHost&LitElement,\n      private readonly changeCallback?:\n          (isKeyboardNavigating: boolean) => void) {\n    this.host.addController(this);\n  }\n\n  hostConnected() {\n    document.addEventListener('keydown', this.keydownEventListener);\n    document.addEventListener('mousedown', this.mousedownEventListener);\n  }\n\n  hostDisconnected() {\n    document.removeEventListener('keydown', this.keydownEventListener);\n    document.removeEventListener('mousedown', this.mousedownEventListener);\n  }\n}\n"]}