{"version":3,"file":"cached_place_lookup.js","sourceRoot":"","sources":["../../../src/place_building_blocks/place_data_provider/cached_place_lookup.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,SAAS,EAAC,MAAM,gCAAgC,CAAC;AAEzD,OAAO,EAAC,MAAM,EAAC,MAAM,wBAAwB,CAAC;AAG9C;;;;GAIG;AACH,KAAK,UAAU,mBAAmB,CAC9B,EAAU,EAAE,QAAsB;IACpC,MAAM,EAAC,KAAK,EAAC,GAAG,MAAM,SAAS,CAAC,aAAa,CAAC,QAAQ,EAAE,QAAQ,CACnC,CAAC;IAC9B,OAAO,IAAI,KAAK,CAAC,EAAC,EAAE,EAAC,CAAU,CAAC;AAClC,CAAC;AAED;;;GAGG;AACH,MAAM,OAAO,iBAAiB;IAG5B;;;;;;OAMG;IACH,YAAY,QAAgB,EAAmB,QAAsB;QAAtB,aAAQ,GAAR,QAAQ,CAAc;QACnE,IAAI,CAAC,KAAK,GAAG,IAAI,MAAM,CAAC,QAAQ,CAAC,CAAC;IACpC,CAAC;IAED;;;;;;OAMG;IACH,QAAQ,CAAC,EAAU;QACjB,MAAM,kBAAkB,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QAC9C,IAAI,kBAAkB;YAAE,OAAO,kBAAkB,CAAC;QAElD,MAAM,eAAe,GAAG,mBAAmB,CAAC,EAAE,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC/D,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,EAAE,eAAe,CAAC,CAAC;QACpC,OAAO,eAAe,CAAC;IACzB,CAAC;IAED;;;OAGG;IACH,WAAW,CAAC,KAAY;QACtB,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,EAAE,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;IACnD,CAAC;CACF","sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {APILoader} from '../../api_loader/api_loader.js';\nimport type {Place} from '../../utils/googlemaps_types.js';\nimport {LRUMap} from '../../utils/lru_map.js';\n\n\n/**\n * Makes a promise that will resolve to a new `Place` with the given ID, or\n * reject with an error if the `Place` constructor throws one. This must be done\n * asynchronously due to the loading of the `Place` constructor from the API.\n */\nasync function makeNewPlacePromise(\n    id: string, consumer?: HTMLElement): Promise<Place> {\n  const {Place} = await APILoader.importLibrary('places', consumer) as\n      typeof google.maps.places;\n  return new Place({id}) as Place;\n}\n\n/**\n * A limited-capacity cache of `Place` objects keyed by place ID. Creates new\n * `Place` objects as needed when they do not exist already.\n */\nexport class CachedPlaceLookup {\n  private readonly cache: LRUMap<string, Promise<Place>>;\n\n  /**\n   * @param capacity - The maximum number of `Place` objects to keep in the\n   *     cache.\n   * @param consumer - Optionally specify the custom element using the cached\n   *     place lookup, to provide more helpful console warnings when the places\n   *     library cannot be loaded.\n   */\n  constructor(capacity: number, private readonly consumer?: HTMLElement) {\n    this.cache = new LRUMap(capacity);\n  }\n\n  /**\n   * Gets the cached `Place` with the given ID. If none exists, a new `Place`\n   * will be created, cached, and returned.\n   *\n   * Note: The returned promise will be rejected with an error from the `Place`\n   * constructor if `id` is an empty string.\n   */\n  getPlace(id: string): Promise<Place> {\n    const cachedPlacePromise = this.cache.get(id);\n    if (cachedPlacePromise) return cachedPlacePromise;\n\n    const newPlacePromise = makeNewPlacePromise(id, this.consumer);\n    this.cache.set(id, newPlacePromise);\n    return newPlacePromise;\n  }\n\n  /**\n   * Adds the provided `Place` to the cache, replacing the existing `Place` if\n   * one exists already.\n   */\n  updatePlace(place: Place) {\n    this.cache.set(place.id, Promise.resolve(place));\n  }\n}\n"]}