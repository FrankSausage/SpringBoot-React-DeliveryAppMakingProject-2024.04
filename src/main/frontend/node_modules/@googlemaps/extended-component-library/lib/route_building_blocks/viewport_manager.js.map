{"version":3,"file":"viewport_manager.js","sourceRoot":"","sources":["../../src/route_building_blocks/viewport_manager.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,SAAS,EAAC,MAAM,6BAA6B,CAAC;AAiBtD;;;GAGG;AACH,MAAM,OAAO,eAAe;IAC1B,YAAqB,GAAe;QAAf,QAAG,GAAH,GAAG,CAAY;QAgBnB,sBAAiB,GAAG,IAAI,GAAG,EAAiB,CAAC;IAhBvB,CAAC;IAIxC;;;;OAIG;IACH,MAAM,CAAC,iBAAiB,CAAC,GAAe;QACtC,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;YACvC,eAAe,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,eAAe,CAAC,GAAG,CAAC,CAAC,CAAC;SAC9D;QACD,OAAO,eAAe,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,CAAE,CAAC;IAC7C,CAAC;IAID;;;OAGG;IACH,KAAK,CAAC,QAAQ,CAAC,SAAwB;QACrC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;YAC1C,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;YACtC,MAAM,IAAI,CAAC,cAAc,EAAE,CAAC;SAC7B;IACH,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,UAAU,CAAC,SAAwB;QACvC,IAAI,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;YACzC,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;YACzC,MAAM,IAAI,CAAC,cAAc,EAAE,CAAC;SAC7B;IACH,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,cAAc;QAClB,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,cAAc,EAAE,CAAC;QAChD,IAAI,WAAW,EAAE;YACf,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;SAC1C;IACH,CAAC;IAEO,KAAK,CAAC,cAAc;QAC1B,IAAI,MAAM,GAAsB,IAAI,CAAC;QACrC,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,iBAAiB,EAAE;YAC9C,MAAM,MAAM,GAAG,SAAS,CAAC,SAAS,EAAE,CAAC;YACrC,IAAI,MAAM,EAAE;gBACV,IAAI,CAAC,MAAM,EAAE;oBACX,MAAM,EAAC,YAAY,EAAC,GAChB,MAAM,SAAS,CAAC,aAAa,CAAC,MAAM,CAAuB,CAAC;oBAChE,MAAM,GAAG,IAAI,YAAY,EAAE,CAAC;iBAC7B;gBACD,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;aACtB;SACF;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;;AA/DuB,yBAAS,GAAG,IAAI,GAAG,EAA+B,AAAzC,CAA0C","sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {APILoader} from '../api_loader/api_loader.js';\nimport {MapElement} from '../utils/googlemaps_types.js';\n\ntype LatLngBounds = google.maps.LatLngBounds;\n\n/**\n * Interface for components that occupy an area on the map in LatLng space, and\n * can be managed by the `ViewportManager`.\n */\nexport interface LatLngBounded {\n  /**\n   * Returns the `LatLngBounds` of the component that should be included in the\n   * map's viewport, or `null` if the component should be ignored.\n   */\n  getBounds(): google.maps.LatLngBounds|google.maps.LatLngBoundsLiteral|null;\n}\n\n/**\n * Manages a map's viewport to fit the bounds of one or several `LatLngBounded`\n * components.\n */\nexport class ViewportManager {\n  constructor(readonly map: MapElement) {}\n\n  private static readonly instances = new Map<MapElement, ViewportManager>();\n\n  /**\n   * Returns the `ViewportManager` instance for the given `MapElement`,\n   * constructing one if none exists already. Each `MapElement` will have only\n   * one associated `ViewportManager` instance.\n   */\n  static getInstanceForMap(map: MapElement) {\n    if (!ViewportManager.instances.has(map)) {\n      ViewportManager.instances.set(map, new ViewportManager(map));\n    }\n    return ViewportManager.instances.get(map)!;\n  }\n\n  private readonly managedComponents = new Set<LatLngBounded>();\n\n  /**\n   * Registers a `LatLngBounded` component to be included in the viewport.\n   * Triggers an `updateViewport()` if the component was not already registered.\n   */\n  async register(component: LatLngBounded) {\n    if (!this.managedComponents.has(component)) {\n      this.managedComponents.add(component);\n      await this.updateViewport();\n    }\n  }\n\n  /**\n   * If the given `LatLngBounded` component is registered, unregisters it and\n   * triggers an `updateViewport()`.\n   */\n  async unregister(component: LatLngBounded) {\n    if (this.managedComponents.has(component)) {\n      this.managedComponents.delete(component);\n      await this.updateViewport();\n    }\n  }\n\n  /**\n   * Updates the map's viewport to fit all registered `LatLngBounded`\n   * components.\n   */\n  async updateViewport() {\n    const boundsUnion = await this.getBoundsUnion();\n    if (boundsUnion) {\n      this.map.innerMap.fitBounds(boundsUnion);\n    }\n  }\n\n  private async getBoundsUnion(): Promise<LatLngBounds|null> {\n    let result: LatLngBounds|null = null;\n    for (const component of this.managedComponents) {\n      const bounds = component.getBounds();\n      if (bounds) {\n        if (!result) {\n          const {LatLngBounds} =\n              await APILoader.importLibrary('core') as typeof google.maps;\n          result = new LatLngBounds();\n        }\n        result.union(bounds);\n      }\n    }\n    return result;\n  }\n}\n"]}