{"version":3,"file":"map_controller.js","sourceRoot":"","sources":["../../src/route_building_blocks/map_controller.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;GAkBG;AAIH,OAAO,EAAC,eAAe,EAAC,MAAM,iCAAiC,CAAC;AAEhE,OAAO,EAAC,QAAQ,EAAC,MAAM,sBAAsB,CAAC;AAE9C,OAAO,EAAC,eAAe,EAAC,MAAM,uBAAuB,CAAC;AAEtD;;;;GAIG;AACH,MAAM,OAAO,aAAa;IAGxB,IAAI,GAAG;QACL,OAAO,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC;IAChC,CAAC;IAED;;;;OAIG;IACH,IAAI,UAAU;QACZ,OAAO,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC;IAClC,CAAC;IAYD,YAA6B,IAAuC;QAAvC,SAAI,GAAJ,IAAI,CAAmC;QAzB5D,gBAAW,GAAG,IAAI,QAAQ,EAAmB,CAAC;QA0BpD,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IAC3B,CAAC;IAED,KAAK,CAAC,aAAa;QACjB,MAAM,MAAM,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAC1C,IAAI,MAAM,EAAE;YACV,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;gBAClC,MAAM,cAAc,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;aAC7C;YACD,MAAM,UAAU,GAAG,MAAoB,CAAC;YACxC,6DAA6D;YAC7D,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;gBACzB,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;gBAC9C,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;aACtE;SACF;IACH,CAAC;IAED,gBAAgB;QACd,IAAI,CAAC,WAAW,GAAG,IAAI,QAAQ,EAAmB,CAAC;IACrD,CAAC;IAED;;;;;OAKG;IACK,mBAAmB;QACzB,KAAK,MAAM,IAAI,IAAI,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;YAC7C,IAAI,IAAI,YAAY,OAAO,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,EAAE;gBAC3D,OAAO,IAAI,CAAC;aACb;SACF;QACD,OAAO,IAAI,CAAC;IACd,CAAC;CACF","sourcesContent":["/**\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {LitElement, ReactiveController, ReactiveControllerHost} from 'lit';\n\nimport {deepParentChain} from '../utils/deep_element_access.js';\nimport {MapElement} from '../utils/googlemaps_types.js';\nimport {Deferred} from '../utils/deferred.js';\n\nimport {ViewportManager} from './viewport_manager.js';\n\n/**\n * Controller that finds a containing `<gmp-map>` element in the DOM when its\n * host is connected, and saves a reference to the internal Map for the host to\n * use.\n */\nexport class MapController implements ReactiveController {\n  private deferredMap = new Deferred<google.maps.Map>();\n\n  get map(): google.maps.Map|undefined {\n    return this.deferredMap.value;\n  }\n\n  /**\n   * Resolves to the map when it's ready. It might not be ready immediately due\n   * to delays in connecting the host or loading the `<gmp-map>` component from\n   * the Maps JS API.\n   */\n  get mapPromise(): Promise<google.maps.Map> {\n    return this.deferredMap.promise;\n  }\n\n  /**\n   * The viewport manager instance for the map. This is first defined when `map`\n   * is defined, so it can be safely accessed after awaiting `mapPromise`.\n   *\n   * When the host is disconnected and `map` is unset, `viewportManager` remains\n   * set to the most recent viewport manager, so that components can be\n   * unregistered in the host's `disconnectedCallback`.\n   */\n  viewportManager?: ViewportManager;\n\n  constructor(private readonly host: ReactiveControllerHost&LitElement) {\n    host.addController(this);\n  }\n\n  async hostConnected() {\n    const gmpMap = this.getContainingGmpMap();\n    if (gmpMap) {\n      if (!customElements.get('gmp-map')) {\n        await customElements.whenDefined('gmp-map');\n      }\n      const mapElement = gmpMap as MapElement;\n      // Make sure the host hasn't been disconnected while awaiting\n      if (this.host.isConnected) {\n        this.deferredMap.resolve(mapElement.innerMap);\n        this.viewportManager = ViewportManager.getInstanceForMap(mapElement);\n      }\n    }\n  }\n\n  hostDisconnected() {\n    this.deferredMap = new Deferred<google.maps.Map>();\n  }\n\n  /**\n   * Finds and returns a `<gmp-map>` in the DOM that contains the host element,\n   * even if the host is in a shadow root. The `<gmp-map>` is identified by its\n   * tag and might not be an instance of MapElement, if the custom element is\n   * not yet defined.\n   */\n  private getContainingGmpMap(): Element|null {\n    for (const node of deepParentChain(this.host)) {\n      if (node instanceof Element && node.localName === 'gmp-map') {\n        return node;\n      }\n    }\n    return null;\n  }\n}\n"]}