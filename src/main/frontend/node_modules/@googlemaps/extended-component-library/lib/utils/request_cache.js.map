{"version":3,"file":"request_cache.js","sourceRoot":"","sources":["../../src/utils/request_cache.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,MAAM,EAAC,MAAM,cAAc,CAAC;AAEpC;;GAEG;AACH,MAAM,OAAO,YAAY;IAEvB;;;;OAIG;IACH,YACI,QAAgB,EACC,WAA0C;QAA1C,gBAAW,GAAX,WAAW,CAA+B;QAC7D,IAAI,CAAC,eAAe,GAAG,IAAI,MAAM,CAAC,QAAQ,CAAC,CAAC;IAC9C,CAAC;IAED;;OAEG;IACH,GAAG,CAAC,OAAoB;QACtB,OAAO,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,IAAI,IAAI,CAAC;IACnE,CAAC;IAED;;;OAGG;IACH,GAAG,CAAC,GAAgB,EAAE,KAA4B;QAChD,MAAM,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;QAC1C,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,aAAa,EAAE,KAAK,CAAC,CAAC;QAC/C,KAAK,CAAC,KAAK,CAAC,CAAC,KAAgB,EAAE,EAAE;YAC/B,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE;gBAC3B,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;aAC5C;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACK,SAAS,CAAC,OAAoB;QAKpC,oEAAoE;QACpE,sEAAsE;QACtE,2CAA2C;QAC3C,MAAM,QAAQ,GAAG,CAAC,GAAW,EAAE,KAAc,EAAE,EAAE;YAC/C,IAAI,KAAK,YAAY,MAAM,IAAI,CAAC,CAAC,KAAK,YAAY,KAAK,CAAC,EAAE;gBACxD,MAAM,GAAG,GAAG,KAAsB,CAAC;gBACnC,MAAM,MAAM,GAAkB,EAAE,CAAC;gBACjC,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE;oBACzC,MAAM,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;iBACxB;gBACD,OAAO,MAAM,CAAC;aACf;iBAAM;gBACL,OAAO,KAAK,CAAC;aACd;QACH,CAAC,CAAC;QACF,OAAO,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;IAC3C,CAAC;CACF","sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {LRUMap} from './lru_map.js';\n\n/**\n * A limited-capacity cache keyed by serialized request objects.\n */\nexport class RequestCache<RequestType, ResponseType, ErrorType extends Error> {\n  private readonly requestCacheMap: LRUMap<string, Promise<ResponseType>>;\n  /**\n   * @param capacity - The maximum number of objects to keep in the cache.\n   * @param shouldRetry - Callback that determines if a request should be\n   * retried, or if the failure should be cached.\n   */\n  constructor(\n      capacity: number,\n      private readonly shouldRetry: (error: ErrorType) => boolean) {\n    this.requestCacheMap = new LRUMap(capacity);\n  }\n\n  /**\n   * Gets the cached result with the given request\n   */\n  get(request: RequestType): Promise<ResponseType>|null {\n    return this.requestCacheMap.get(this.serialize(request)) ?? null;\n  }\n\n  /**\n   * Adds the provided request to the cache, replacing the\n   * existing result if one exists already.\n   */\n  set(key: RequestType, value: Promise<ResponseType>) {\n    const serializedKey = this.serialize(key);\n    this.requestCacheMap.set(serializedKey, value);\n    value.catch((error: ErrorType) => {\n      if (this.shouldRetry(error)) {\n        this.requestCacheMap.delete(serializedKey);\n      }\n    });\n  }\n\n  /**\n   * Deterministically serializes arbitrary objects to strings.\n   */\n  private serialize(request: RequestType): string {\n    interface UnknownObject {\n      [key: string]: unknown;\n    }\n\n    // Non-numeric keys in modern JS are iterated in order of insertion.\n    // Make a new object and insert the keys in alphabetical order so that\n    // the object is serialized alphabetically.\n    const replacer = (key: string, value: unknown) => {\n      if (value instanceof Object && !(value instanceof Array)) {\n        const obj = value as UnknownObject;\n        const sorted: UnknownObject = {};\n        for (const key of Object.keys(obj).sort()) {\n          sorted[key] = obj[key];\n        }\n        return sorted;\n      } else {\n        return value;\n      }\n    };\n    return JSON.stringify(request, replacer);\n  }\n}"]}