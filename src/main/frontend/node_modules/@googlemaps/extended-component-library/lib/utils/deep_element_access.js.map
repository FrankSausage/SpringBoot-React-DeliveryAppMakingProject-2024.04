{"version":3,"file":"deep_element_access.js","sourceRoot":"","sources":["../../src/utils/deep_element_access.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH;;;;;;;;GAQG;AACH,MAAM,UAAU,oBAAoB;IAClC,IAAI,OAAO,GAAG,QAAQ,CAAC,aAAa,CAAC;IACrC,IAAI,CAAC,OAAO;QAAE,OAAO,IAAI,CAAC;IAC1B,IAAI,IAAI,CAAC;IACT,OAAO,CAAC,IAAI,GAAG,OAAO,CAAC,UAAU,EAAE,aAAa,CAAC,EAAE;QACjD,OAAO,GAAG,IAAI,CAAC;KAChB;IACD,OAAO,OAAO,CAAC;AACjB,CAAC;AAED;;;GAGG;AACH,MAAM,SAAS,CAAC,CAAC,eAAe,CAAC,IAAU;IACzC,OAAO,IAAI,EAAE;QACX,MAAM,IAAI,CAAC;QACX,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC;SACxB;aAAM,IAAI,IAAI,YAAY,UAAU,EAAE;YACrC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;SAClB;aAAM;YACL,OAAO;SACR;KACF;AACH,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,YAAY,CACxB,QAA6B,EAAE,SAA8B;IAC/D,IAAI,CAAC,QAAQ,IAAI,CAAC,SAAS;QAAE,OAAO,KAAK,CAAC;IAC1C,KAAK,MAAM,IAAI,IAAI,eAAe,CAAC,SAAS,CAAC,EAAE;QAC7C,IAAI,IAAI,KAAK,QAAQ;YAAE,OAAO,IAAI,CAAC;KACpC;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,gBAAgB,CAC5B,SAAiB,EAAE,SAA8B;IACnD,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,CAAC,IAAI,CAAC,SAAS;QAAE,OAAO,KAAK,CAAC;IACzD,MAAM,WAAW,GAAG,IAAI,GAAG,CAAC,SAAS,CAAC,CAAC;IACvC,KAAK,MAAM,IAAI,IAAI,eAAe,CAAC,SAAS,CAAC,EAAE;QAC7C,IAAI,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC;YAAE,OAAO,IAAI,CAAC;KACxC;IACD,OAAO,KAAK,CAAC;AACf,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Gets the active element, even if it's nested inside shadow DOMs.\n *\n * If the active element is in a shadow DOM, document.activeElement will be the\n * light DOM element whose shadow DOM contains it, so this is needed to find the\n * true active element.\n *\n * @return The active element, or `<body>` or null if there is none.\n */\nexport function getDeepActiveElement(): Element|null {\n  let current = document.activeElement;\n  if (!current) return null;\n  let next;\n  while ((next = current.shadowRoot?.activeElement)) {\n    current = next;\n  }\n  return current;\n}\n\n/**\n * Generator function that yields the chain of parent nodes upwards in the DOM\n * starting at `node`, and piercing shadow boundaries.\n */\nexport function* deepParentChain(node: Node) {\n  while (true) {\n    yield node;\n    if (node.parentNode) {\n      node = node.parentNode;\n    } else if (node instanceof ShadowRoot) {\n      node = node.host;\n    } else {\n      return;\n    }\n  }\n}\n\n/**\n * Behaves like Node.contains() but accounts for shadow descendants as well.\n *\n * @param rootNode - A node that might be the ancestor.\n * @param otherNode - A node that might be the descendant.\n * @return true if otherNode is a light or shadow descendant of rootNode.\n */\nexport function deepContains(\n    rootNode: Node|null|undefined, otherNode: Node|null|undefined): boolean {\n  if (!rootNode || !otherNode) return false;\n  for (const node of deepParentChain(otherNode)) {\n    if (node === rootNode) return true;\n  }\n  return false;\n}\n\n/**\n * Returns true if for some node in rootNodes, otherNode is a light or shadow\n * descendant of the node. Uses a single search in\n * O(|rootNodes| + (depth of otherNode)).\n */\nexport function someDeepContains(\n    rootNodes: Node[], otherNode: Node|null|undefined): boolean {\n  if ((rootNodes.length === 0) || !otherNode) return false;\n  const rootNodeSet = new Set(rootNodes);\n  for (const node of deepParentChain(otherNode)) {\n    if (rootNodeSet.has(node)) return true;\n  }\n  return false;\n}\n"]}