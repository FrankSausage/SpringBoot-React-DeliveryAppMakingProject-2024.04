{"version":3,"file":"lru_map.js","sourceRoot":"","sources":["../../src/utils/lru_map.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH;;;GAGG;AACH,MAAM,OAAO,MAAM;IAGjB;;;;OAIG;IACH,YAA6B,QAAgB;QAAhB,aAAQ,GAAR,QAAQ,CAAQ;QAP5B,QAAG,GAAG,IAAI,GAAG,EAAQ,CAAC;IAOS,CAAC;IAEjD,GAAG,CAAC,GAAM;QACR,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC;QAC5B,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAC3B,CAAC;IAED,GAAG,CAAC,GAAM;QACR,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC;QAC5B,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAC3B,CAAC;IAED,GAAG,CAAC,GAAM,EAAE,KAAQ;QAClB,4EAA4E;QAC5E,qBAAqB;QACrB,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QACjB,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;QACzB,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,EAAE;YACjC,MAAM,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC;YACjC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;SACzB;IACH,CAAC;IAED,MAAM,CAAC,GAAM;QACX,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;YACrB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;SACtB;IACH,CAAC;IAED;;;;OAIG;IACK,iBAAiB,CAAC,GAAM;QAC9B,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;YACrB,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAE,CAAC;YACjC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;YACrB,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;SAC1B;IACH,CAAC;CACF","sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * A limited-capacity map with a least-recently-used eviction policy. Includes\n * the operations `get`, `set`, and `has`, which behave the same as on a `Map`.\n */\nexport class LRUMap<K, V> {\n  private readonly map = new Map<K, V>();\n\n  /**\n   * @param capacity - The maximum number of entries allowed in the map. When\n   *     inserting a new entry beyond this limit, the least recently used entry\n   *     will be evicted.\n   */\n  constructor(private readonly capacity: number) {}\n\n  has(key: K): boolean {\n    this.reinsertIfPresent(key);\n    return this.map.has(key);\n  }\n\n  get(key: K): V|undefined {\n    this.reinsertIfPresent(key);\n    return this.map.get(key);\n  }\n\n  set(key: K, value: V) {\n    // Rather than reinserting the entry, just delete it to avoid the extra call\n    // to this.map.set().\n    this.delete(key);\n    this.map.set(key, value);\n    if (this.map.size > this.capacity) {\n      const [lruKey] = this.map.keys();\n      this.map.delete(lruKey);\n    }\n  }\n\n  delete(key: K) {\n    if (this.map.has(key)) {\n      this.map.delete(key);\n    }\n  }\n\n  /**\n   * Reinserts the entry with the given key if it exists. This is used to\n   * implement the LRU policy: the native `Map` is ordered by insertion order,\n   * so the reinsertion keeps it ordered by access time.\n   */\n  private reinsertIfPresent(key: K) {\n    if (this.map.has(key)) {\n      const value = this.map.get(key)!;\n      this.map.delete(key);\n      this.map.set(key, value);\n    }\n  }\n}\n"]}